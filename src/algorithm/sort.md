# 排序

可通过排序[算法动画](https://visualgo.net/zh/sorting)帮助理解各种排序原理。


## 一、**冒泡排序（Bubble Sort）**

> 每次相邻元素对比，把较大的交换到右边去，每轮能找到一个本轮最大的，第一轮选出来最大的，第二轮选出第二大的，被选出来的不再参与比较。
> 

```jsx
53421 => 34215 => 32145 … => 12345

function sort(arr){
  let len = arr.length
  if(len <= 1)return arr

  for (let i = 0; i < len - 1; i++) { // 总共多少轮
    let flag = false // 退出标志，如果一轮没有交换，说明大家位置都排好了
    for (let j = 0; j < len - i; j++) { // 每轮参与排序元素的范围
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
        flag = true
      }    
    }
    if(!flag) break
  }
  return arr
}
const newArr = sort([5, 4, 3, 2, 1])
console.log(newArr)
```


## 二、 插入排序（Insertion Sort）

> 首先将数据**已排序区间**和**未排序区间**，**初始已排序区间**只有一个元素，就是数组的第一个元素。插入算法的核心思想是**取未排序区间**中的元素，在**已排序区间**中找到合适的插入位置将其插入，类似于摆牌，找到牌的大小位置，插入进去。
> 

```jsx
var sortArray = function(nums) {
  const len = nums.length
  if(len <= 1) return nums

  for(let i = 1; i < len; i++){  // 从第二个开始依次插入到已排序区
    let value = nums[i] // 要排序的当前值
    let j = i - 1
    while(j >= 0 && nums[j] > value){ // 倒序在已排序区寻找要插入的位置
      nums[j + 1] = nums[j]
      j--
    }

    nums[j + 1] = value
  }
  return nums
};
```


## 三、希尔排序（Shell Sort）

> 希尔排序是**插入排序升级版**，也称为**缩小增量排序**，同时是冲破O(n^2）的第一批算法之一。
> 

### 3.1 **希尔排序来源和原理**

插入排序的平均时间复杂度是**O（n^2），**显然并不是一个高效的排序算法，我们可以从插入排序的两个特点入手进行优化：

- **在大多数元素已经有序的情况下，插入排序的工作量较小**

      如果一个数组大部分元素都有序，那么数组中的元素自然不需要频繁地进行比较和交换。

- **在元素数量较少的情况下，插入排序的工作量较小**
    
    插入排序的工作量和 n 的平方成正比，如果 n 比较小，那么排序的工作量自然要小得多。
    

基于上面两点，**Donald Shell** 于1959年提出一种排序算法，对数组进行分组排序，粗略调整。

分组就是确定一个跨度，然后每隔一个**跨度**（或**增量**）选出一个元素，组成一组，这样把数组分成若干组，然后对小组内元素进行**插入排序**。排序后再调整跨度，继续分组排序，直到跨度为1，再排序一次。

**示例：[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]**

![https://pic.jianhunxia.com/imgs/20211102144554shellSort.png](https://pic.jianhunxia.com/imgs/20211102144554shellSort.png)

上面示例中所使用的分组跨度（5，2，1），被称为希尔排序的**增量**，增量的选择可以有很多种，我们在示例中所用的逐步折半的增量方法，是Donald Shell在发明希尔排序时提出的一种朴素方法，被称为**希尔增量**。

有些极端情况，希尔增量会造成排序效率比插入排序低，比如[2, 1, 5, 3, 7, 6, 9, 8]，无论是以4为增量，还是以2为增量，每组内部的元素都没有任何交换。一直到我们把增量缩减为1，数组才会按照直接插入排序的方式进行调整，白白增加了分组操作的成本。

**更多有效的增量方式**

为了保证分组粗调没有盲区，每一轮的增量需要彼此“互质”，也就是没有除1之外的公约数。

于是，人们相继提出了很多种增量方式，其中最具代表性的是**Hibbard增量**和**Sedgewick增量**。

- **Hibbard增量序列**：1，3，7，15... 通项公式 2^k-1，最坏时间复杂度是**O（n^(3/2)）**
- **Sedgewick增量序列**：1, 5, 19, 41, 109......通项公式 9*4^k - 9*2^k + 1 或者 4^k - 3*2^k + 1，最坏时间复杂度是**O（n^(4/3)）**

希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。

### 3.2 **希尔排序代码实现**

```jsx
// 实现1
function shellSort(arr) {
  for (let gap = arr.length >> 1; gap > 0; gap >>= 1) {
    for (let i = gap; i < arr.length; i++) {
      let temp = arr[i];
      for (let j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j];
      }
      arr[j + gap] = temp;
    }
  }
  return arr;
};

// 实现2
const sortArray = arr => {
  const len = arr.length
  let gap = 1
  while(gap < len / 3){
    gap = 3 * gap + 1 // 动态增量
  }
  for(; gap > 0; gap = Math.floor(gap / 3)){ // 增量改变
    for(let i = gap; i < len; i++){ // 插入排序的i，从下标gap开始排
      const current = arr[i]
      let j = i - gap // 前一个已经排好的元素，i = gap 时刚好是第一个元素
      while(j >= 0 && arr[j] > current ){ // 寻找待插入元素的位置
        arr[j + gap] = arr[j] // 不满足则挪到后一个元素位置
        j -= gap
      }
      arr[j + gap] = current // 把当前元素插入到找到的位置上
    }
  }
  return arr
}
```

### 3.3 希尔排序性能分析

**1. 希尔排序是原地排序算法吗 ？**
希尔排序过程中，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1) 。所以，希尔排序是`原地排序`算法。

**2. 希尔排序是稳定的排序算法吗 ？**
单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。
因此，希尔排序`不稳定`。

**3. 希尔排序的时间复杂度是多少 ？**
**最好时间复杂度**：T(n) = O(n)
**最坏时间复杂度**：T(n) = O(n^2)
**平均时间复杂度**：T(n) = 取决于增量序列

## 四、选择排序（Selection Sort）

> 选择排序类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其作为已排序区间的最大值。
> 

```jsx
// 类似于选拔，先摸底，然后直接选走
// 从第一个开始，用一个下标记录找到右边的最小元素，然后把这个和当前元素交换位置
function selectSort (nums) {
  const len = nums.length
  for(let i = 0; i < len - 1; i++){
    let minIndex = i
    for(let j = i + 1; j < len; j++){
      if(nums[minIndex] > nums[j]){
        minIndex = j // 先把最小的元素的的下标记录下来
      }
    }
    if(minIndex !== i){ // 如果当前元素不是它和它右侧所有元素中最小的，就把最小的和当前元素交换
      const temp = nums[i]
      nums[i] = nums[minIndex]
      nums[minIndex] = temp
    }
  }
  return nums
}
```
选择排序**是一种不稳定的排序算法**。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性，比如 [5，8，5，2，9] 这样一组数据。

正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

## 五、归并排序（Merge Sort）

> 如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

归并排序使用的就是**分治思想**。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。

![https://pic.jianhunxia.com/imgs/20220706104552mergeSort.png](https://pic.jianhunxia.com/imgs/20220706104552mergeSort.png)

```jsx
// 采用递归方法，其实是由下到上地去合并排序
function mergeSort(array) {
  var length = array.length;
  if(length < 2) {
    return array;
  }
  var m = (length >> 1), // 位运算右移，相当于除以 2 取整
    left = array.slice(0, m),
    right = array.slice(m)  // 拆分为两个子数组
  return merge(mergeSort(left), mergeSort(right)) // 子数组继续递归拆分,然后再合并
}

function merge(left, right){ // 合并两个子数组
  var result = [];
  while (left.length && right.length) {
    // 判断的条件是小于或等于, 如果只是小于,那么排序将不稳定
    var item = left[0] <= right[0] ? left.shift() : right.shift();
    result.push(item);
  }
  return result.concat(left.length ? left : right);
}
```

### 5.1 归并排序是稳定的排序算法吗？

在合并的过程中，如果 A[p...q]和 A[q+1...r]之间有值相同的元素，先把 A[p...q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序**是一个稳定的排序算法。**

### 5.2 归并排序的时间复杂度是多少？

归并排序涉及递归，我们借此学习下递归代码的时间复杂度分析。

我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)，另外merge() 函数合并两个有序子数组的时间复杂度是 O(n)，所以计算如下：

```jsx
T(1) = C；              // n = 1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2 * T(n/2) + n； // n > 1

T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......

// 通过这样一步一步分解推导，我们可以得到：
T(n) = 2^kT(n/2^k) + kn。
当 T(n/2^k) = T(1) 时，也就是 n/2^k = 1，我们得到 k = log2n 
我们将 k 值代入上面的公式，得到 T(n)=Cn + nlog2n 
如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。
```

所以归并排序的时间复杂度是 O(nlogn)

### 5.3 归并排序的空间复杂度是多少？

归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。

尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 **O(n)**。

尽管归并排序的时间复杂度任何情况下都是 O(nlogn)，但是并没有像快排那样应用广泛，就是因为归并排序**不是原地排序算法**。

## 六、快速排序（Quick Sort）

> **快速排序**简称为`“快排”`，也是分治思想，但是和归并排序完全不同。核心思想就是在排序数组中选一个元素作为分区点，小于它的放左边，大于它的放右边，再递归处理左右两边数组。
> 

![https://pic.jianhunxia.com/imgs/20220706110018quickSort.png](https://pic.jianhunxia.com/imgs/20220706110018quickSort.png)
```jsx
// 实现1：取最后一个值作为中间值，然后小于它的放左边，大于它的放右边，再递归处理左右数组并合并
function quickSort(array) {
  let pivot = array[array.length - 1]
  let left = array.filter((v, i) => v <= pivot && i != array.length -1)
  let right = array.filter(v => v > pivot)
  return [...quickSort(left), pivot, ...quickSort(right)]
}

// 实现2：取中间值作为 pivot
function quickSort (arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr.splice(pivotIndex, 1)[0];
  
  const left = [];
  const right = [];

  for (let i = 0; i < arr.length; i++){
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot], quickSort(right));
};

// 实现3: 原地分区
var sortArray = (arr) => {
  return quickSortCC(arr, 0, arr.length - 1)
}

const quickSortCC = (arr, left, right) => {
  if (left >= right) return arr
  const mid = partition(arr, left, right) // 分为左右两部分
  quickSortCC(arr, left, mid - 1)
  quickSortCC(arr, mid + 1, right) // 中间下标为mid的元素已经排好了
  return arr // 原地排序所以返回原数组即可
}

// 分区函数，小于 pivot 的放到i左边，大于的不动，pivot再放到 i 的位置
const partition = (arr, l, r) => {
  const pos = Math.floor(Math.random() * (r - l + 1)) + l
  swap(arr, pos, r)
  const pivot = arr[r] // 取末尾元素作为中间数
  let i = l // i 为左边待交换的位置
  for (let j = l; j < r; j++) {
    if (arr[j] <= pivot) { // 小于等于中间数的挪到 i 左边
      swap(arr, j, i)
      i++
    }
  }
  swap(arr, r, i) // 把 pivot 放到中间位置
  return i
}

// 交换两个数
const swap = (arr, i, j) => {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}
```

### 6.1 快排是稳定算法么？

因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，6，3，5，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。

所以，快速排序**并不是一个稳定的排序算法**。

### 6.2 快排是原地算法么？

我们通过原地分区函数可以保证空间复杂度得是 O(1)，所以**快排是原地算法。**

### 6.3 快排的时间复杂度是多少？

快排也是用递归来实现的，也适用对于递归代码的时间复杂度分析的公式。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那**快排的时间复杂度递推求解公式跟归并是相同的**。所以，**快排的时间复杂度也是 O(nlogn)。**

**这里有个分析经验：**T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n^2)。而且，我们也有很多方法将这个概率降到很低，后续章节会提到。

### 6.4 快排和归并对比

- 快排和归并用的都是分治思想，递推公式和递归代码也非常相似，它们的区别就在于处理过程。
- 归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。
- 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但合并函数无法在原地执行，导致它不是原地算法。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

![https://pic.jianhunxia.com/imgs/20211028151243quick_merge.png](https://pic.jianhunxia.com/imgs/20211028151243quick_merge.png)

## 七、桶排序（Bucket sort）

**线性排序（Linear sort）：**算法的时间复杂度是线性的O(n) ，所以我们把这类排序算法叫作**线性排序（Linear sort），**三种常见的线性排序算法排序算法为**桶排序、计数排序、基数排序**。

复杂度是 O(n) 的原因这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。

首先介绍下**桶排序：**

> 核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。
> 

如果要排序的数据有 `n` 个，我们把它们均匀地划分到 `m` 个桶内，每个桶里就有 `k=n/m` 个元素。桶内使用快速排序，时间复杂度为 `O(k * logk)，`m 个桶的时间复杂度就是 `O(m * k * logk)`，因为 `k = n/m`，所以桶排序的时间复杂度就是 `O(n*log(n/m))`。当桶的个数 m 接近数据个数 n 时，`log(n/m)` 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 `O(n)`。

桶排序性能很好，但是对要排序数据的要求是非常苛刻的。

- 首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。
- 其次，数据在各个桶之间的分布是比较均匀的。

**适用场景：**

桶排序比较适合用在外部排序，就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

**案例：**

> 有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是内存有限只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中，如何处理？
> 

我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02...99）。

**理想的情况**: ****如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。

**真实情况**：订单金额在 1 元到 10 万元之间不一定是均匀分布 ，有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。针对这些划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元....901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。

## 八、计数排序（Counting sort）

> 计数排序其实是桶排序的一种特殊情况，当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。
> 

**适用场景：**

- 适合数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合了。
- 只能给非负整数排序，如果要排序的数据是其他类型的，就要转化为非负整数。

**应用场景：**

比如高考查分数系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？

考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。

## 九、基数排序（Radix sort）

> 数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。
> 

**适用场景：**

- 针对范围不大的数据，将数据划分成不同的桶来实现排序。
- 数据可以划分成高低位，位之间有递进关系。
- 每一位的数据范围不能太大，要可以用线性排序算法来排序。

**应用场景：**

假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，如何排序？

假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。

可以先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。

根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 **O(k*n)**。当 k 不大的时候可以看作常量，所以**基数排序的时间复杂度就近似于 O(n)**。

**线性排序总结：**

三种线性排序对数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。


### 题目推荐

- [数组排序](https://leetcode-cn.com/problems/sort-an-array/)